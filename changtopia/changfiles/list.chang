module list

def get(l, n)
  match l
    [] -> return $nothing end
    [x, <<rest>>] ->
      if n == 0
        return x
      end
      return get(rest, n - 1)
    end
  end
end

def length(list)
  return core:length(list)
end

def range(start, finish)
  _range = def (n, acc)
    if n == finish
      return acc
    end
    return @_range(n+1, [<<acc>>, n])
  end
  return @_range(start, [])
end

def partition(l, n)
  segment_length = core:cast(core:length(l) / n, 'integer')

  _partition = def (l, current_segment, curr_length, segments_left, segments)
    if curr_length == segment_length
      if segments_left == 1
        return [<<segments>>, [<<current_segment>>, <<l>>]]
      end
      return @_partition(l, [], 0, segments_left - 1, [<<segments>>, current_segment])
    end
    match l
      [] -> return [<<segments>>, current_segment] end
      [x ,<<rest>>] ->
        return @_partition(rest, [<<current_segment>>, x], curr_length + 1, segments_left, segments)
      end
    end
  end
  return @_partition(l, [], 0, n, [])
end

def pad_left(list, pad, length)
  if core:length(list) >= length
    return list
  end
  padding = repeat(pad, length - core:length(list))
  return [<<padding>>, <<list>>]
end

def pad_right(list, pad, length)
  if core:length(list) >= length
    return list
  end
  padding = repeat(pad, length - core:length(list))
  return [<<list>>, <<padding>>]
end

def contains(list, element)
  match list
    [] -> return false end
    [x, <<rest>>] ->
      if x == element
        return true
      end
        return contains(rest, element)
    end
  end
end

def repeat(x, length)
  _ = def (n, acc)
    if n >= length
      return acc
    end
    return @_(n + 1, [<<acc>>, x])
  end
  return @_(0, [])
end

def flatten(lists)
  --return _flatten(lists, [])
  return core:flatten(lists)
end

def _flatten(lists, acc)
  match lists
    [] ->
      return acc
    end
    [x] ->
      if core:is_array(x)
        return [<<acc>>, <<x>>]
      end
      return lists
    end
    [head, <<tail>>] ->
      if core:is_array(head)
        return _flatten(tail, [<<acc>>, <<head>>])
      end
      return lists
    end
  end
  return acc
end

def drop_empty(list)
  drop = def (list, acc)
    match list
      [] -> return acc end
      [[], <<rest>>] -> return @drop(rest, acc) end
      [x, <<rest>>] -> return @drop(rest, [<<acc>>, x]) end
    end
  end
  return @drop(list, [])
end

def join_with(list, delim)
  return _join_with(list, delim, [])
end

def _join_with(list, delim, acc)
  match list
    [x, <<rest>>] ->
      return _join_with(rest, delim, [<<acc>>, <<x>>, <<delim>>])
    end
    [x] ->
      return [<<acc>>, <<x>>]
    end
    [] ->
      return acc
    end
  end
end

def split_by(list, delimiter)
  return _split_by(list, delimiter, [], [])
end

def _split_by(list, delimiter, current_word, res)
  match list
    [] ->
      return [<<res>>, current_word]
    end
    [thing, <<tail>>] ->
      if thing == delimiter
        return _split_by(tail, delimiter,  [], [<<res>>, current_word])
      end
      return _split_by(tail, delimiter, [<<current_word>>, thing], res)
    end
  end
  -- I think this a bug here... I have to think at some point in my life
  return res
end

def all(list)
  match list
    [x] ->
      return x
    end
    [x ,<<rest>>] ->
      return x && all(rest)
    end
  end
end

def map(list, fn)
  return _map(list, fn, [])
end

def _map(list, fn, res)
  match list
    [] ->
      return res
    end
    [x, <<rest>>] ->
      return _map(rest, fn, [<<res>>, core:run(fn, x)])
    end
  end
end

def zip(list1, list2)
  return _zip(list1, list2, [])
end

def _zip(l1, l2, res)
  match l1
    [] ->
      return res
    end
    whatever ->
      return _zip(tail(l1), tail(l2), [<<res>>, [head(l1), head(l2)]])
    end
  end
end

def split_at(arr, index)
  thing = def (n, tail, head)
    match tail
      [x , <<rest>>] ->
        match n < index
          true ->
            return @thing(n + 1, rest, [<<head>>, x])
          end
          false ->
            return [head, tail]
          end
        end
      end
    end
    return [[],[]]
  end

  return @thing(0, arr, [])
end

def slice(from, to, arr)
  skip = def (n, acc)
    match acc
      [_ , <<rest>>] ->
        match n < from
          true ->
            return @skip(n + 1, rest)
          end
          false ->
            return acc
          end
        end
      end
    end
    return []
  end

  arr = @skip(0, arr)

  grab = def (n, arr, res)
    match arr
      [x, <<rest>>] ->
        match n < to - from
          true ->
            return @grab(n + 1, rest, [<<res>>, x])
          end
          false ->
            return [<<res>>, x]
          end
        end
      end
      whatever ->
        return res
      end
    end
  end

  return @grab(0, arr, [])
end

def head(l)
  [h, <<_>>] = l
  return h
end

def tail(l)
  [_, <<t>>] = l
  return t
end

def pmap(list, fn)
  cpu_count = core:send(core:io_pid(), $cpu_count)
  segments = partition(list, cpu_count)
  spawner = def (segment)
    pid =  core:spawn(['list', 'pmap_worker'], segment, fn)
    core:link(pid)
    return pid
  end
  workers = map(segments, spawner)
  return core:flatten(map(workers, def (worker) return core:send(worker, $ok) end))
end

def pmap_worker(list, fn)
  result = map(list, fn)
  listener = def (sender, payload)
    return result
  end
  core:listen(listener)
  -- Something is wrong here. this return is completely unncessary
  -- but without it just gets stuck.
  return $ok
end


-- Basic merge sort for now
def sort(list, fn)
  if core:length(list) <= 1 return list end
  [left, right] = list:partition(list, 2)

  left = sort(left, fn)
  right = sort(right, fn)

  merge = def (l, r, res)
    match [core:length(l) == 0, core:length(r) == 0]
      [false, false] ->
        [l_head, <<l_rest>>] = l
        [r_head, <<r_rest>>] = r
        comp = @fn(l_head, r_head)
        if comp <= 0
          return @merge(l_rest, r, [<<res>>, l_head])
        end
        return @merge(l, r_rest, [<<res>>, r_head])
      end
      whatever -> return [<<res>>, <<l>>, <<r>>] end
    end
  end

  return @merge(left, right, [])
end
