module list

def get(l, n)
  match l
    [] -> return $nothing end
    [x, <<rest>>] ->
      if n == 0
        return x
      end
      return get(rest, n - 1)
    end
  end
end

def length(list)
  return bif:length(list)
end

def range(start, finish)
  _range = def (n, acc)
    if n == finish
      return acc
    end
    return @_range(n+1, [<<acc>>, n])
  end
  return @_range(start, [])
end

def partition(l, n)
  segment_length = bif:cast(bif:length(l) / n, 'integer')

  _partition = def (l, current_segment, curr_length, segments_left, segments)
    if curr_length == segment_length
      if segments_left == 1
        return [<<segments>>, [<<current_segment>>, <<l>>]]
      end
      return @_partition(l, [], 0, segments_left - 1, [<<segments>>, current_segment])
    end
    match l
      [] -> return [<<segments>>, current_segment] end
      [x ,<<rest>>] ->
        return @_partition(rest, [<<current_segment>>, x], curr_length + 1, segments_left, segments)
      end
    end
  end
  return @_partition(l, [], 0, n, [])
end

def pad_left(list, pad, length)
  if bif:length(list) >= length
    return list
  end
  padding = repeat(pad, length - bif:length(list))
  return [<<padding>>, <<list>>]
end

def pad_right(list, pad, length)
  if bif:length(list) >= length
    return list
  end
  padding = repeat(pad, length - bif:length(list))
  return [<<list>>, <<padding>>]
end

def contains(list, element)
  match list
    [] -> return false end
    [x, <<rest>>] ->
      if x == element
        return true
      end
        return contains(rest, element)
    end
  end
end

def repeat(x, length)
  _ = def (n, acc)
    if n >= length
      return acc
    end
    return @_(n + 1, [<<acc>>, x])
  end
  return @_(0, [])
end

def flatten(lists)
  return _flatten(lists, [])
end

def _flatten(lists, acc)
  match lists
    [] ->
      return acc
    end
    [x] ->
      if bif:is_array(x)
        return [<<acc>>, <<x>>]
      end
      return lists
    end
    [head, <<tail>>] ->
      if bif:is_array(head)
        return _flatten(tail, [<<acc>>, <<head>>])
      end
      return lists
    end
  end
  return acc
end

def drop_empty(list)
  drop = def (list, acc)
    match list
      [] -> return acc end
      [[], <<rest>>] -> return @drop(rest, acc) end
      [x, <<rest>>] -> return @drop(rest, [<<acc>>, x]) end
    end
  end
  return @drop(list, [])
end

def join_with(list, delim)
  return _join_with(list, delim, [])
end

def _join_with(list, delim, acc)
  match list
    [x, <<rest>>] ->
      return _join_with(rest, delim, [<<acc>>, <<x>>, <<delim>>])
    end
    [x] ->
      return [<<acc>>, <<x>>]
    end
    [] ->
      return acc
    end
  end
end

def split_by(list, delimiter)
  return _split_by(list, delimiter, [], [])
end

def _split_by(list, delimiter, current_word, res)
  match list
    [] ->
      return [<<res>>, current_word]
    end
    [thing, <<tail>>] ->
      if thing == delimiter
        return _split_by(tail, delimiter,  [], [<<res>>, current_word])
      end
      return _split_by(tail, delimiter, [<<current_word>>, thing], res)
    end
  end
  -- I think this a bug here... I have to think at some point in my life
  return res
end

def all(list)
  match list
    [x] ->
      return x
    end
    [x ,<<rest>>] ->
      return x && all(rest)
    end
  end
end

def map(list, fn)
  return _map(list, fn, [])
end

def _map(list, fn, res)
  match list
    [] ->
      return res
    end
    [x, <<rest>>] ->
      return _map(rest, fn, [<<res>>, bif:run(fn, x)])
    end
  end
end

def zip(list1, list2)
  return _zip(list1, list2, [])
end

def _zip(l1, l2, res)
  match l1
    [] ->
      return res
    end
    whatever ->
      return _zip(tail(l1), tail(l2), [<<res>>, [head(l1), head(l2)]])
    end
  end
end

def split_at(arr, index)
  thing = def (n, tail, head)
    match tail
      [x , <<rest>>] ->
        match n < index
          true ->
            return @thing(n + 1, rest, [<<head>>, x])
          end
          false ->
            return [head, tail]
          end
        end
      end
    end
    return [[],[]]
  end

  return @thing(0, arr, [])
end

def slice(from, to, arr)
  skip = def (n, acc)
    match acc
      [_ , <<rest>>] ->
        match n < from
          true ->
            return @skip(n + 1, rest)
          end
          false ->
            return acc
          end
        end
      end
    end
    return []
  end

  arr = @skip(0, arr)

  grab = def (n, arr, res)
    match arr
      [x, <<rest>>] ->
        match n < to - from
          true ->
            return @grab(n + 1, rest, [<<res>>, x])
          end
          false ->
            return [<<res>>, x]
          end
        end
      end
      whatever ->
        return res
      end
    end
  end

  return @grab(0, arr, [])
end

def head(l)
  [h, <<_>>] = l
  return h
end

def tail(l)
  [_, <<t>>] = l
  return t
end
