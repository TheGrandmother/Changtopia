module trace

-- Lol on the fact that I am even attempting this.

def min(a,b)
  if a < b
    return a
  end
  return b
end

def max(a,b)
  if a >= b
    return a
  end
  return b
end


-- ========= VECTOR STUFF ============

-- Simplifications:
--  Camera at [0, 0, -1] pointing [0, 0, 1]
--  Viewport centered at origin and having width and height 1
--  FOV = 90deg
def get_pixel_ray(p_x, p_y, x_count, y_count)
  pixel_vec = vec3:norm([
    p_x/x_count - 1 / 2,
    p_y/y_count - 1 / 2,
    1
  ])
  return pixel_vec
end

def random_reflection(normal)
  return random_reflection(normal, .5)
end

def random_reflection(normal, spread)
  b3 = normal
  [_x, _, __] = b3
  match core:abs(_x) < .5
    true -> diff = [1,0,0] end
    false -> diff = [0,1,0] end
  end
  b1 = vec3:norm(vec3:cross(b3, diff))
  b2 = vec3:cross(b1, b3)

  z = core:rand_range(core:cos(core:pi() * spread), 1)
  r = core:sqrt(1-z*z)
  theta = core:rand_range(-1*core:pi(), core:pi())
  x = r * core:cos(theta)
  y = r * core:sin(theta)
  return vec3:norm(vec3:add(vec3:add(vec3:mul(b1, x), vec3:mul(b2, y)), vec3:mul(b3, z)))
end

def reflect(normal, direction)
  -- r = d -2(n.d)n
  return vec3:sub(direction, vec3:mul(normal, vec3:dot(normal, direction) * 2))
end


-- ========= GEOMETRY =======

-- https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection
def triangle_intersect_test(ray, triangle)
  [v0, v1, v2] = triangle
  [start, direction] = ray

  v0v1 = vec3:sub(v1, v0)
  v0v2 = vec3:sub(v2, v0)
  pvec = vec3:cross(direction, v0v2)
  det = vec3:dot(v0v1, pvec)
  if core:abs(det) <= 0.0000001
    return $miss
  end

  inv_det = 1 / det

  tvec = vec3:sub(start, v0)
  u = vec3:dot(pvec, tvec) * inv_det
  if u < 0
    return $miss
  end

  if u > 1
    return $miss
  end

  qvec = vec3:cross(tvec, v0v1)
  v = vec3:dot(direction, qvec) * inv_det

  if v < 0
    return $miss
  end

  if  u + v > 1
    return $miss
  end

  t = vec3:dot(v0v2, qvec) * inv_det
  if t <= 0.00000001
    return $miss
  end
  return t
end

def triangle_normal(triangle)
  [v0, v1, v2] = triangle
  v0v1 = vec3:sub(v1, v0)
  v0v2 = vec3:sub(v2, v0)
  return vec3:norm(vec3:cross(v0v1,v0v2))
end

def sphere_intersect_test(ray, sphere)
  [start, direction] = ray
  [center, radius] = sphere
  l = vec3:sub(start, center) --thing from start to center
  thing = vec3:dot(direction, l)
  mag_l = vec3:mag(l)
  disc = thing*thing - (mag_l * mag_l - radius * radius)
  if disc < 0
    return $miss
  end
  t = min((-1*thing) + core:sqrt(disc), (-1*thing) - core:sqrt(disc))
  if t <= 0
    return $miss
  end
  return t
end

def sphere_normal(sphere, point)
  [center, radius] = sphere
  return vec3:norm(vec3:sub(point, center))
end

def get_normal([_, $triangle, geo, <<_>>], _)
  return triangle_normal(geo)
end

def get_normal([_, $sphere, geo, <<_>>], point)
  return sphere_normal(geo, point)
end

def find_nearest([], ray, nearest, _)
  return nearest
end

def find_nearest([obj, <<rest>>], ray, nearest, id)
  [_, type, geo, mat, <<meta>>] = obj
  match meta
    [hint_id] ->
      if id != $none && hint_id == id
        return find_nearest(rest, ray, nearest, id)
      end
    end
  end
  match type
    $sphere -> t = sphere_intersect_test(ray, geo) end
    $triangle -> t = triangle_intersect_test(ray, geo) end
  end
  if t == $miss
    return find_nearest(rest, ray, nearest, id)
  end
  if nearest == $miss
    return find_nearest(rest, ray, [t, obj], id)
  end
  [old_t, _] = nearest
  if t < old_t
    return find_nearest(rest, ray, [t, obj], id)
  end
  return find_nearest(rest, ray, nearest, id)
end

def find_nearest(objects, ray)
  return find_nearest(objects, ray, $miss, $none)
end

def trace(objects, ray, nearest)
  return trace(objects, ray, nearest, 20, true)
end

def trace(objects, ray, _, 0, _)
  return [0,0,0]
end

def trace(objects, ray, nearest, bounce, first)
  [solids, hints] = objects
  if nearest == $unkown
    nearest = find_nearest(solids, ray)
    if nearest == $miss
      return [0, 0, 0]
    end
  end
  [t, obj] = nearest
  [_id, _type, _meh, mat, <<_>>] = obj
  [color, diffuse_reflexivity, emittance, direct_reflexivity] = mat
  emitted_color = vec3:mul(color, emittance)

  if emittance > 0.95
    --not affected by incoming light
    return vec3:mul(emitted_color, emittance)
  end

  [origin, direction] = ray
  point = vec3:add(origin, vec3:mul(direction, t))

  normal = get_normal(obj, point)

  -- HINT STEP

  [x, <<_>>] = direction

  find_light_paths = def (hints, rays)
    match hints
      [] -> return rays end
      [hint, <<rest>>] ->
        [pos, id] = hint
        light_dir = vec3:sub(pos, point)
        if vec3:dot(light_dir, normal) < 0
          return @find_light_paths(rest, rays)
        end
        if light_dir == [0,0,0]
          return @find_light_paths(rest, rays)
        end
        distance_to_light = vec3:mag(light_dir)
        light_dir = vec3:norm(light_dir)
        match find_nearest(solids, [point, light_dir], $miss, id)
          $miss ->
            return @find_light_paths(rest, [<<rays>>, [light_dir, id]])
          end
          [t, obj] ->
            point_of_intersection = vec3:add(point, vec3:mul(light_dir, t))
            distance_to_intersection = vec3:mag(vec3:sub(point_of_intersection, point))
            if distance_to_intersection > distance_to_light
              return @find_light_paths(rest, [<<rays>>, [light_dir, id]])
            end
            return @find_light_paths(rest, rays)
          end
        end
      end
    end
  end

  hint_vectors = @find_light_paths(hints, [])

  drop_by_id = def(obj, id)
    match obj
      [_, _, _, _] -> return false end
      [_, _, _, _, hint_id] -> return hint_id == id end
      _ -> return false end
    end
  end

  hint_count = core:length(hint_vectors)

  trace_hints = def (hint_vectors, light)
    match hint_vectors
      [] -> return light end
      [hint, <<rest>>] ->
        [vector, id] = hint
        --new_ray = random_reflection(vector, 0.0)
        new_ray = vector
        if vec3:dot(new_ray, normal) < 0
          -- Casting ray behind object
          return @trace_hints(rest, light)
        end
        match find_nearest(list:filter(solids, def (obj) return @drop_by_id(obj, id) end), [point, vector])
          $miss -> return @trace_hints(rest, light) end
          [t, obj] ->
            [_, _, _, mat, <<_>>] = obj
            [light_color, _, hint_emittance, _hint_reflextivity] = mat
            thing = vec3:dot(new_ray, normal) * diffuse_reflexivity
            emitted_hint_light = vec3:mul(light_color, hint_emittance)
            return @trace_hints(rest, vec3:add(light, vec3:mul(emitted_hint_light, thing)))
          end
        end
      end
    end
  end

  hint_color = vec3:mul(@trace_hints(hint_vectors, [0,0,0]),1)

  -- DIFUSE STEP

  diffuse_color = [0, 0, 0]
  if diffuse_reflexivity > 0.01
    new_ray = random_reflection(normal)
    incoming = trace(objects, [point , new_ray], $unkown, bounce - 1, false)
    match incoming
      [0,0,0] -> diffuse_color = [0,0,0] end
      _ ->
        thing = vec3:dot(new_ray, normal) * diffuse_reflexivity
        diffuse_color = vec3:mul(incoming, thing)
      end
    end
  end

  -- DIRECT STEP

  direct_color = [0, 0, 0]
  if direct_reflexivity > 0
    new_ray = reflect(normal, direction)
    incoming = trace(objects, [point , new_ray], $unkown, bounce - 1, false)
    match incoming
      [0,0,0] -> direct_color = [0,0,0] end
      _ ->
        direct_color = vec3:mul(incoming, direct_reflexivity)
      end
    end
  end

  total_traced_color = vec3:add(vec3:add(hint_color, diffuse_color), direct_color)
  if total_traced_color == [0,0,0]
    return [0,0,0]
  end

  return vec3:mul(vec3:proj(color, total_traced_color), vec3:mag(total_traced_color))
end

-- ============ RENDERING =================

def plot_pixel(x, y, color)
  f = def (c)
    return min(core:floor(c*255), 255)
  end
  [r, g, b] = color
  io:print_string([
    <<core:ansi_cursor_to(x, y)>>,
    <<core:ansi_color(@f(r), @f(g), @f(b))>>,
    <<'█'>>,
    <<core:ansi_color_reset()>>]
    )
end

def tag_objects(objects)
  return tag_objects(objects, 0,[])
end

def tag_objects([], _, acc)
  return acc
end

def tag_objects([obj, <<rest>>], n, acc)
  return tag_objects(rest, n + 1, [<<acc>>, [n, <<obj>>]])
end

def render(width, height, _scene)
  [_objects, hints] = _scene
  objects = tag_objects(_objects)
  scene = [objects, hints]

  io:debug_raw([width, height])
  io:print_string('Performing precalculations...\n')
  [ids, data, sample_counts] = [
    <<pre_compute(width, height, scene)>>,
    list:map(list:range(height),
    def (_) return list:repeat(width) end)
  ]

  io:print_string('Starting workers...\n')

  sampels_per_pass = 5

  workers = list:map(list:range(core:send(core:io_pid(), $cpu_count)), def (_)
    return core:spawn(['trace', 'worker'], width, height, core:my_pid(), scene, data, sampels_per_pass)
  end)

  listener = def (pixels, n, sender, payload)
    match payload
      [$render_results, y, samples] ->
        core:send(sender, [$render, select_next_row(n, height)])
        match list:get(pixels, y)
          [_, []] ->
            prev_samples = 0
            new_row = list:map(samples, def (s) return vec3:mul(s, 1 / sampels_per_pass) end)
          end
          [prev_samples, row] ->
            new_row = list:map(list:zip(samples, row), def (meh)
              [new, old] = meh
              return vec3:mul(vec3:add(vec3:mul(old, prev_samples), new), 1/(prev_samples+sampels_per_pass))
            end)
          end
        end
        draw_line(y, width, new_row, prev_samples + sampels_per_pass)
        new_pixels = list:set(pixels, y, [prev_samples + sampels_per_pass, new_row])
        return [$rendered, new_pixels, n + 1]
      end
      [$error, <<_>>] ->
        io:debug_raw(payload)
        io:print_string(io:format_error(payload))
        return $quit
      end
    end
  end

  handler = def (pixels, n)
    match core:listen(listener, pixels, n)
      [$rendered, new_pixels, n] -> return @handler(new_pixels, n) end
      $quit -> return $ok end
    end
  end

  list:for_each(workers, def (pid) core:send(pid, [$render, core:floor(core:rand_range(0, height-1))]) end)
  @handler(list:repeat([0,[]], height), 0)

  return $ok
end

def select_next_row(n, height)
  return n % (height - 1)
  -- return core:floor(core:rand_range(0, height-1))
  -- return core:floor(core:rand_range(10, 15))
  -- return 10
end


def worker(width, height, parent, scene, data, sampels_per_pass)
  core:link(parent)
  io:print_string('Worker started\n')
  listener = def (sender, payload)
    match payload
      [$render, y] ->
        pixels = render_line(y, width, height, list:get(data, y), scene, sampels_per_pass)
        core:send(sender,[$render_results, y, pixels])
        return $ok
      end
      [$quit] -> return $quit end
    end
    return $ok
  end
  handler = def ()
    match core:listen(listener)
      $ok -> return @handler() end
      $quit -> return $ok end
    end
  end
  @handler()
end

def pre_compute(width, height, scene)
  return pre_compute(width, height, height - 1, 0, scene, [], [])
end

def pre_compute(width, height, -1, _, scene, ids, data)
  io:debug_raw(ids)
  return [list:partition(ids, height), list:partition(data, height)]
end

def pre_compute(width, height, y, x, scene, ids, data)
  if x == width
    return pre_compute(width, height, y - 1, 0, scene, ids, data)
  end
  pixel_direction = get_pixel_ray(x, y, width, height)
  origin = [0,0,-1]
  ray = [origin, pixel_direction]
  [solids, hints] = scene
  match find_nearest(solids, ray)
    $miss -> return  pre_compute(width, height, y, x + 1, scene, [<<ids>>, $void], [<<data>>, $void]) end
    nearest ->
      [t, obj] = nearest
      [id, <<_>>] = obj
      return pre_compute(width, height, y, x + 1, scene, [<<ids>>, id], [<<data>>, [nearest, ray]])
    end
  end
end

def draw_line(y, width, pixels, samples)
  make_pixel = def (color)
    [r,g,b] = color
    f = def (c)
      return min(core:floor(c*255), 255)
    end
    [r, g, b] = color
    return([
      <<core:ansi_color(@f(r), @f(g), @f(b))>>,
      <<'█'>>
      ])
  end
  string = [<<core:ansi_cursor_to(0, y)>>, <<core:flatten(list:map(pixels, make_pixel))>>, <<core:ansi_color_reset()>>, <<core:cast(samples, 'string')>>]
  io:print_string(string)
end

def render_line(y, width, height, precomp, scene, samples)
  render_pixel = def (meh)
    [x, precomp] = meh
    if precomp == $void
      return [0,0,0]
    end
    [nearest, ray, <<meh>>] = precomp
    take_samples = def (n, res)
      if n == samples
        return res
      end
      color = trace(scene, ray, nearest)
      return @take_samples(n + 1, vec3:add(res, color))
    end
    return @take_samples(0, [0,0,0])
  end
  return list:map(list:zip(list:range(width), precomp), render_pixel)
end

def _entry([])
  if _test() == false
    return $ok
  end
  io:print_string(core:ansi_cursor_to(0,0))
  io:print_string(core:ansi_clear_screen())
  utils:load_module('colors')
  utils:load_module('scenes')
  [width, height] = core:request(core:io_pid(), $get_console_size)
  scene = scenes:make_room()
  --[meh, _] =scene
  --render(height*2,height, [meh, []])
  render(height*2,height, scene)
  return $ok
end

def _test()
  utils:load_module('testing')
  utils:load_module('vec3')
  suite = [
    ['sphere_intersect_test hit',
      def (superv)
        sphere = [[5,0,0],1]
        ray = [[0,0,0], [1,0,0]]
        intersect = sphere_intersect_test(ray, sphere)
        testing:assert(superv, 'does not miss', intersect != $miss)
        testing:assert(superv, 'Hits at [4 0 0]', [4, 0, 0], vec3:mul([1,0,0], intersect))
      end
    ],
    ['sphere_intersect_test miss',
      def (superv)
        sphere = [[0,5,0],1]
        ray = [[0,0,0], [1,0,0]]
        intersect = sphere_intersect_test(ray, sphere)
        testing:assert(superv, 'does not miss', intersect == $miss)
      end
    ],
    ['random_ref',
      def (superv)
        norm = [core:rand_range(-1,1), core:rand_range(-1,1) , core:rand_range(-1,1)]
        testing:assert(superv, 'n·random(n) > 0', vec3:dot(random_reflection(norm),norm) > 0)
      end
    ],
    ['triangle intersection test',
      def (superv)
        triangle = [
          [-1, -1, 0],
          [0, 1, 0],
          [1, -1, 0]
        ]
        ray = [[0,0,-1], [0,0,1]]
        testing:assert(superv, 'hits at 1', triangle_intersect_test(ray, triangle), 1)
        ray = [[0,0,-1], [0,0,-1]]
        testing:assert(superv, 'reversed misses', triangle_intersect_test(ray, triangle), $miss)
      end
    ],
    ['reflect',
      def (superv)
        testing:assert(superv, 'headon is same but backwards', reflect([0,1,0], [0,-1,0]), [0,1,0])
        testing:assert(superv, 'orthog remains the same', reflect([0,1,0], [1,0,0]), [1,0,0])
        testing:assert(superv, 'basic dude', reflect([0,1,0], [1,-1,0]), [1,1,0])
      end
    ],
  ]
  return testing:run_suite('Trace', suite)
end

