module trace

-- Lol on the fact that I am even attempting this.

def min(a,b)
  if a < b
    return a
  end
  return b
end

def max(a,b)
  if a >= b
    return a
  end
  return b
end


-- ========= VECTOR STUFF ============

-- Simplifications:
--  Camera at [0, 0, -1] pointing [0, 0, 1]
--  Viewport centered at origin and having width and height 1
--  FOV = 90deg
def get_pixel_ray(p_x, p_y, x_count, y_count)
  pixel_vec = vec3:norm([
    p_x/x_count - 1 / 2,
    p_y/y_count - 1 / 2,
    1
  ])
  return pixel_vec
end

def random_reflection(normal)
  return random_reflection(normal, .5)
end

def random_reflection(normal, spread)
  b3 = normal
  [_x, _, __] = b3
  match core:abs(_x) < .5
    true -> diff = [1,0,0] end
    false -> diff = [0,1,0] end
  end
  b1 = vec3:norm(vec3:cross(b3, diff))
  b2 = vec3:cross(b1, b3)

  z = core:rand_range(core:cos(core:pi() * spread), 1)
  r = core:sqrt(1-z*z)
  theta = core:rand_range(-1*core:pi(), core:pi())
  x = r * core:cos(theta)
  y = r * core:sin(theta)
  return vec3:norm(vec3:add(vec3:add(vec3:mul(b1, x), vec3:mul(b2, y)), vec3:mul(b3, z)))
end

def reflect(normal, direction)
  -- r = d -2(n.d)n
  return vec3:sub(direction, vec3:mul(normal, vec3:dot(normal, direction) * 2))
end


-- ========= GEOMETRY =======

-- https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection
def triangle_intersect_test(ray, triangle)
  [v0, v1, v2] = triangle
  [start, direction] = ray

  v0v1 = vec3:sub(v1, v0)
  v0v2 = vec3:sub(v2, v0)
  pvec = vec3:cross(direction, v0v2)
  det = vec3:dot(v0v1, pvec)
  if core:abs(det) <= 0.0000001
    return $miss
  end

  inv_det = 1 / det

  tvec = vec3:sub(start, v0)
  u = vec3:dot(pvec, tvec) * inv_det
  if u < 0
    return $miss
  end

  if u > 1
    return $miss
  end

  qvec = vec3:cross(tvec, v0v1)
  v = vec3:dot(direction, qvec) * inv_det

  if v < 0
    return $miss
  end

  if  u + v > 1
    return $miss
  end

  t = vec3:dot(v0v2, qvec) * inv_det
  if t <= 0.00000001
    return $miss
  end
  return t
end

def triangle_normal(triangle)
  [v0, v1, v2] = triangle
  v0v1 = vec3:sub(v1, v0)
  v0v2 = vec3:sub(v2, v0)
  return vec3:norm(vec3:cross(v0v1,v0v2))
end

def sphere_intersect_test(ray, sphere)
  [start, direction] = ray
  [center, radius] = sphere
  l = vec3:sub(start, center) --thing from start to center
  thing = vec3:dot(direction, l)
  mag_l = vec3:mag(l)
  disc = thing*thing - (mag_l * mag_l - radius * radius)
  if disc < 0
    return $miss
  end
  t = min((-1*thing) + core:sqrt(disc), (-1*thing) - core:sqrt(disc))
  if t <= 0
    return $miss
  end
  return t
end

def sphere_normal(sphere, point)
  [center, radius] = sphere
  return vec3:norm(vec3:sub(point, center))
end

def get_normal([$triangle, geo, <<_>>], _)
  return triangle_normal(geo)
end

def get_normal([$sphere, geo, <<_>>], point)
  return sphere_normal(geo, point)
end

def find_nearest([], ray, nearest, _)
  return nearest
end

def find_nearest([obj, <<rest>>], ray, nearest, id)
  [type, geo, mat, <<meta>>] = obj
  match meta
    [hint_id] ->
      if id != $none && hint_id == id
        return find_nearest(rest, ray, nearest, id)
      end
    end
  end
  match type
    $sphere -> t = sphere_intersect_test(ray, geo) end
    $triangle -> t = triangle_intersect_test(ray, geo) end
  end
  if t == $miss
    return find_nearest(rest, ray, nearest, id)
  end
  if nearest == $miss
    return find_nearest(rest, ray, [t, obj], id)
  end
  [old_t, _] = nearest
  if t < old_t
    return find_nearest(rest, ray, [t, obj], id)
  end
  return find_nearest(rest, ray, nearest, id)
end

def find_nearest(objects, ray)
  return find_nearest(objects, ray, $miss, $none)
end

def trace(objects, ray, nearest)
  return trace(objects, ray, nearest, 2, true)
end

def trace(objects, ray, _, 0, _)
  return [0,0,0]
end

def trace(objects, ray, nearest, bounce, first)
  [solids, hints] = objects
  if nearest == $unkown
    nearest = find_nearest(solids, ray)
    if nearest == $miss
      return [0, 0, 0]
    end
  end
  [t, obj] = nearest
  [_type, _meh, mat, <<_>>] = obj
  [color, diffuse_reflexivity, emittance, direct_reflexivity] = mat
  emitted_color = vec3:mul(color, emittance)

  if emittance > 0.95
    --not affected by incoming light
    return emitted_color
  end

  [origin, direction] = ray
  point = vec3:add(origin, vec3:mul(direction, t))

  normal = get_normal(obj, point)

  -- HINT STEP

  [x, <<_>>] = direction

  find_light_paths = def (hints, rays)
    match hints
      [] -> return rays end
      [hint, <<rest>>] ->
        [pos, id] = hint
        light_dir = vec3:sub(pos, point)
        if vec3:dot(light_dir, normal) < 0
          return @find_light_paths(rest, rays)
        end
        if light_dir == [0,0,0]
          return @find_light_paths(rest, rays)
        end
        distance_to_light = vec3:mag(light_dir)
        light_dir = vec3:norm(light_dir)
        match find_nearest(solids, [point, light_dir], $miss, id)
          $miss ->
            return @find_light_paths(rest, [<<rays>>, [light_dir, id]])
          end
          [t, obj] ->
            point_of_intersection = vec3:add(point, vec3:mul(light_dir, t))
            distance_to_intersection = vec3:mag(vec3:sub(point_of_intersection, point))
            if distance_to_intersection > distance_to_light
              return @find_light_paths(rest, [<<rays>>, [light_dir, id]])
            end
            return @find_light_paths(rest, rays)
          end
        end
      end
    end
  end

  hint_vectors = @find_light_paths(hints, [])

  drop_by_id = def(obj, id)
    match obj
      [_, __, ___] -> return false end
      [_, __, ___, obj_id] -> return obj_id == id end
      _ -> return false end
    end
  end

  hint_count = core:length(hint_vectors)

  trace_hints = def (hint_vectors, light)
    match hint_vectors
      [] -> return light end
      [hint, <<rest>>] ->
        [vector, id] = hint
        new_ray = random_reflection(vector, 0.05)
        if vec3:dot(new_ray, normal) < 0
          -- Casting ray behind object
          return @trace_hints(rest, light)
        end
        match find_nearest(list:filter(solids, def (obj) return @drop_by_id(obj, id) end), [point, vector])
          $miss -> return @trace_hints(rest, light) end
          [t, obj] ->
            [_, __, mat, <<_>>] = obj
            [light_color, _, hint_emittance, _hint_reflextivity] = mat
            thing = vec3:dot(new_ray, normal) * diffuse_reflexivity
            emitted_hint_light = vec3:mul(light_color, hint_emittance)
            return @trace_hints(rest, vec3:add(light, vec3:mul(emitted_hint_light, thing)))
          end
        end
      end
    end
  end

  hint_color = vec3:mul(@trace_hints(hint_vectors, [0,0,0]),1)

  -- DIFUSE STEP

  new_ray = random_reflection(normal)

  incoming = trace(objects, [point , new_ray], $unkown, bounce - 1, false)

  match incoming
    [0,0,0] -> reflected_color = [0,0,0] end
    _ ->
      thing = vec3:dot(new_ray, normal) * diffuse_reflexivity
      reflected_color = vec3:mul(incoming, thing)
    end
  end

  -- DIRECT STEP

  direct_color = [0, 0, 0]
  if direct_reflexivity > 0
    new_ray = reflect(normal, direction)
    otto = vec3:add(new_ray, [0,0,0])
    incoming = trace(objects, [point , new_ray], $unkown, bounce - 1, false)
    match incoming
      [0,0,0] -> direct_color = [0,0,0] end
      _ ->
        direct_color = vec3:mul(incoming, direct_reflexivity)
      end
    end
  end

  total_traced_color = vec3:add(vec3:add(hint_color, reflected_color), direct_color)
  if total_traced_color == [0,0,0]
    return [0,0,0]
  end

  return vec3:mul(vec3:proj(color, total_traced_color), vec3:mag(total_traced_color))
end

-- ============ RENDERING =================

def plot_pixel(x, y, color)
  f = def (c)
    return min(core:floor(c*255), 255)
  end
  [r, g, b] = color
  io:print_string([
    <<core:ansi_cursor_to(x, y)>>,
    <<core:ansi_color(@f(r), @f(g), @f(b))>>,
    <<'█'>>,
    <<core:ansi_color_reset()>>]
    )
end

def render_line(y, width, height, objects)
  render_pixel = def (x)
    if x == 0
      return $ok
    end
    pixel_ray = get_pixel_ray(x, y, width, height)
    ray = [[0,0,-1], pixel_ray]
    [solids, _] = objects
    match find_nearest(solids, ray)
      $miss -> color = [0, 0, 0] end
      nearest ->
        color = adaptive_trace(objects, ray, 10 , 1, .03, nearest)
      end
    end
    plot_pixel(x,y,color)
    return @render_pixel(x - 1)
  end
  @render_pixel(width)
  return $ok
end


def average_trace(objects, ray, samples)
  return average_trace(objects, ray, samples, samples, [0,0,0])
end

def average_trace(objects, ray, 0, samples, col)
  return col
end

def average_trace(objects, ray, n, s, [_r, _g, _b])
  match trace(objects, ray)
    $miss -> return [0,0,0] end
    [r,g,b] -> return average_trace(objects, ray, n - 1, s, [_r + r/s, _g + g/s, _b + b/s]) end
  end
end

def adaptive_trace(objects, ray, set_size, max, threshold, nearest)
  initial_set = trace_set(objects, ray, set_size, nearest)
  return adaptive_trace(objects, ray, set_size, max, threshold, initial_set, nearest)
end

def adaptive_trace(objects, ray, set_size, max, threshold, old_set, nearest)
  cap = def (c) return min(c, 1) end
  set = trace_set(objects, ray, set_size, nearest)
  color = vec3:mul(vec3:add(set, old_set), 1/2)
  if vec3:mag(color) < 0.01 && set_size > max / 4
    return color
  end
  diff = vec3:mag(vec3:sub(list:map(set, cap), list:map(old_set, cap)))
  if diff < threshold
    return color
  end
  if set_size * 2 > max
    return color
  end
  return adaptive_trace(objects, ray, set_size*2, max, threshold, color, nearest)
end

def trace_set(objects, ray, s, nearest)
  return trace_set(objects, ray, s, s, [0,0,0], nearest)
end

def trace_set(objects, ray, s, 0, acc, nearest)
  return acc
end

def trace_set(objects, ray, s, n, [_r, _g, _b], nearest)
  match trace(objects, ray, nearest)
    $miss -> return [0,0,0] end
    [r,g,b] -> return trace_set(objects, ray, s, n - 1, [_r + r/s, _g + g/s, _b + b/s], nearest) end
  end
  return 1
end

def render(width, height)
  plain_wall = [[1,1,1],1, 1]
  -- objects = [
  --   [--solids [type, geometry, [color, diffuse, emittance, reflection], <hint_id>]
  --     [$sphere, [[0, 1, 4], 1], [[1,1,1], 1, 0]],
  --     [$sphere, [[0, -2, 4], 1], [[1,1,1], 1, 0]],
  --     [$sphere, [[0, -.5, 4], .3], [[1,1,1], 0, 1], 0]
  --   ],
  --   [--light hints
  --     [[0, -.5, 4], 0]
  --   ]
  -- ]
  objects = make_room()

  worker = def (y)
    return render_line(y, width, height, objects)
  end

  res = list:pmap(list:range(height), worker)
  match res
    [$error, <<_>>] ->
      io:print_strings([
        core:ansi_cursor_to(0,0),
        core:ansi_clear_screen(),
        io:format_error(res)
      ])
    end
    res -> return $ok end
  end

  return $ok

end






def _entry([])
  if _test() == false
    return $ok
  end
  io:print_string(core:ansi_cursor_to(0,0))
  io:print_string(core:ansi_clear_screen())
  utils:load_module('colors')
  [width, height] = core:request(core:io_pid(), $get_console_size)
  render(height*2,height)
  return $ok
end

def _test()
  utils:load_module('testing')
  utils:load_module('vec3')
  suite = [
    ['sphere_intersect_test hit',
      def (superv)
        sphere = [[5,0,0],1]
        ray = [[0,0,0], [1,0,0]]
        intersect = sphere_intersect_test(ray, sphere)
        testing:assert(superv, 'does not miss', intersect != $miss)
        testing:assert(superv, 'Hits at [4 0 0]', [4, 0, 0], vec3:mul([1,0,0], intersect))
      end
    ],
    ['sphere_intersect_test miss',
      def (superv)
        sphere = [[0,5,0],1]
        ray = [[0,0,0], [1,0,0]]
        intersect = sphere_intersect_test(ray, sphere)
        testing:assert(superv, 'does not miss', intersect == $miss)
      end
    ],
    ['random_ref',
      def (superv)
        norm = [core:rand_range(-1,1), core:rand_range(-1,1) , core:rand_range(-1,1)]
        testing:assert(superv, 'n·random(n) > 0', vec3:dot(random_reflection(norm),norm) > 0)
      end
    ],
    ['triangle intersection test',
      def (superv)
        triangle = [
          [-1, -1, 0],
          [0, 1, 0],
          [1, -1, 0]
        ]
        ray = [[0,0,-1], [0,0,1]]
        testing:assert(superv, 'hits at 1', triangle_intersect_test(ray, triangle), 1)
        ray = [[0,0,-1], [0,0,-1]]
        testing:assert(superv, 'reversed misses', triangle_intersect_test(ray, triangle), $miss)
      end
    ],
    ['reflect',
      def (superv)
        testing:assert(superv, 'headon is same but backwards', reflect([0,1,0], [0,-1,0]), [0,1,0])
        testing:assert(superv, 'orthog remains the same', reflect([0,1,0], [1,0,0]), [1,0,0])
        testing:assert(superv, 'basic dude', reflect([0,1,0], [1,-1,0]), [1,1,0])
      end
    ],
  ]
  return testing:run_suite('Trace', suite)
end

def make_room()
  max_depth = 5
  min_depth = -1.1
  return [
     [
      [-- Backwall 1
        $triangle,
        [
          [2, -2, max_depth],
          [-2, -2, max_depth],
          [-2, 2, max_depth],
        ],
        [[1, 1, 1], 1, 0, 0]
      ],
      [-- Backwall 2
        $triangle,
        [
          [2, 2, max_depth],
          [2, -2, max_depth],
          [-2, 2, max_depth],
        ],
        [[1, 1, 1], 1, 0, 0]
      ],
      [-- front wall 1
        $triangle,
        [
          [-2, 2, min_depth],
          [-2, -2, min_depth],
          [2, -2, min_depth],
        ],
        [[1, 1, 1], 1, 0, 0]
      ],
      [-- front wall 2
        $triangle,
        [
          [-2, 2, min_depth],
          [2, -2, min_depth],
          [2, 2, min_depth],
        ],
        [[1, 1, 1], 1, 0, 0]
      ],
      [-- Left wall 1
        $triangle,
        [
          [-2, 2, max_depth],
          [-2, -2, max_depth],
          [-2, -2, min_depth],
        ],
        [[.1, .9, .1], 1, 0, 0]
      ],
      [-- Left wall 2
        $triangle,
        [
          [-2, -2, min_depth],
          [-2, 2, min_depth],
          [-2, 2, max_depth],
        ],
        [[.1, .9, .1], 1, 0, 0]
      ],
      [-- right wall 1
        $triangle,
        [
          [2, -2, min_depth],
          [2, -2, max_depth],
          [2, 2, max_depth],
        ],
        [[.9, .1, .1], 1, 0, 0]
      ],
      [-- right wall 2
        $triangle,
        [
          [2, 2, max_depth],
          [2, 2, min_depth],
          [2, -2, min_depth],
        ],
        [[.9, .1, .1], 1, 0, 0]
      ],
      [-- bottom wall 1
        $triangle,
        [
          [2, 2, max_depth],
          [-2, 2, max_depth],
          [-2, 2, min_depth],
        ],
        [[1, 1, 1], 1, 0, 0]
      ],
      [-- bottom wall 2
        $triangle,
        [
          [-2, 2, min_depth],
          [2, 2, min_depth],
          [2, 2, max_depth],
        ],
        [[1, 1, 1], 1, 0, 0]
      ],
      [-- top wall 1
        $triangle,
        [
          [-2, -2, max_depth],
          [2, -2, max_depth],
          [-2, -2, min_depth],
        ],
        [[1, 1, 1], 1, 0, 0]
      ],
      [-- top wall 2
        $triangle,
        [
          [-2, -2, min_depth],
          [2, -2, max_depth],
          [2, -2, min_depth],
        ],
        [[1, 1, 1], 1, 0, 0]
      ],
      [-- Lamp 1
        $triangle,
        [
          [1, -1.9, 4],
          [-1, -1.9, 4],
          [-1, -1.9, 1],
        ],
        [[1, 1, 1], 0, 1, 0],
        0
      ],
      [-- Lamp 2
        $triangle,
        [
          [1, -1.9, 4],
          [1, -1.9, 1],
          [-1, -1.9, 1],
        ],
        [[1, 1, 1], 0, 1, 0],
        0
      ],
      [-- Lamp 1
        $triangle,
        [
          [-1, -1.85, 1],
          [-1, -1.85, 4],
          [1, -1.85, 4],
        ],
        [[1, 1, 1], 0, 1, 0],
        0
      ],
      [-- Lamp 2
        $triangle,
        [
          [-1, -1.85, 1],
          [1, -1.85, 1],
          [1, -1.85, 4],
        ],
        [[1, 1, 1], 0, 1, 0],
        0
      ],
      [
       $sphere,
       [
         [-.5,0,4],
         .3
       ],
       [[1, 0, .5], .3, .5, 0],
       1
      ],
      [
       $sphere,
       [
         [1.3,1.5,4.3],
         .7
       ],
       [[0, 0, 1], .8, 0, 0]
      ],
      [
       $sphere,
       [
         [-1.2,1.4,4.3],
         .8
       ],
       [[1, .7, .5], .3, 0, .9]
      ],
    ],
    [
      [[0, -1.9, 3.5], 0],
    ]
  ]
end
