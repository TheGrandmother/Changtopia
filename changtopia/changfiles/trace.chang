module trace

-- Lol on the fact that I am even attempting this.

def min(a,b)
  if a < b
    return a
  end
  return b
end

-- Simplifications:
--  Camera at [0, 0, -1] pointing [0, 0, 1]
--  Viewport centered at origin and having width and height 1
--  FOV = 90deg
def get_pixel_ray(p_x, p_y, x_count, y_count)
  pixel_vec = vec3:norm([
    p_x/x_count - 1 / 2,
    p_y/y_count - 1 / 2,
    1
  ])
  return pixel_vec
end

-- ========= GEOMETRY =======

-- https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection
def triangle_intersect_test(ray, triangle)
  [v0, v1, v2] = triangle
  [start, direction] = ray

  v0v1 = vec3:sub(v1, v0)
  v0v2 = vec3:sub(v2, v0)
  pvec = vec3:cross(direction, v0v2)
  det = vec3:dot(v0v1, pvec)
  if core:abs(det) < 0.001
    return $miss
  end

  inv_det = 1 / det

  tvec = vec3:sub(start, v0)
  u = vec3:dot(pvec, tvec) * inv_det
  if u < 0
    return $miss
  end

  if u > 1
    return $miss
  end

  qvec = vec3:cross(tvec, v0v1)
  v = vec3:dot(direction, qvec) * inv_det

  if v < 0
    return $miss
  end

  if  u + v > 1
    return $miss
  end

  t = vec3:dot(v0v2, qvec) * inv_det
  if t < 0
    return $miss
  end
  return t
end

def triangle_normal(triangle)
  [v0, v1, v2] = triangle
  v0v1 = vec3:sub(v1, v0)
  v0v2 = vec3:sub(v2, v0)
  return vec3:norm(vec3:cross(v0v1, v0v2))
end

def sphere_intersect_test(ray, sphere)
  [start, direction] = ray
  [center, radius] = sphere
  l = vec3:sub(start, center) --thing from start to center
  thing = vec3:dot(direction, l)
  mag_l = vec3:mag(l)
  disc = thing*thing - (mag_l * mag_l - radius * radius)
  if disc < 0
    return $miss
  end
  t = min((-1*thing) + core:sqrt(disc), (-1*thing) - core:sqrt(disc))
  if t < 0
    return $miss
  end
  return t
end

def sphere_normal(sphere, point)
  [center, radius] = sphere
  return vec3:norm(vec3:sub(point, center))
end

def get_normal([$triangle, geo, _], _)
  return triangle_normal(geo)
end

def get_normal([$sphere, geo, _], point)
  return sphere_normal(geo, point)
end


def random_reflection(normal)
  b3 = vec3:norm(normal)
  [_x, _, __] = b3
  match core:abs(_x) < .5
    true -> diff = [1,0,0] end
    false -> diff = [0,1,0] end
  end
  b1 = vec3:norm(vec3:cross(b3, diff))
  b2 = vec3:cross(b1, b3)

  z = core:rand_range(core:cos(core:pi()/2), 1)
  -- z = core:rand_range(0.75, 1)
  -- io:debug_raw(z)
  r = core:sqrt(1-z*z)
  theta = core:rand_range(-1*core:pi(), core:pi())
  x = r * core:cos(theta)
  y = r * core:sin(theta)
  return vec3:norm(vec3:add(vec3:add(vec3:mul(b1, x), vec3:mul(b2, y)), vec3:mul(b3, z)))
end

def find_nearest([], ray, nearest)
  return nearest
end

def find_nearest([obj, <<rest>>], ray, nearest)
  [type, geo, mat] = obj
  match type
    $sphere -> t = sphere_intersect_test(ray, geo) end
    $triangle -> t = triangle_intersect_test(ray, geo) end
  end
  if t == $miss
    return find_nearest(rest, ray, nearest)
  end
  if nearest == $miss
    return find_nearest(rest, ray, [t, obj])
  end
  [old_t, _] = nearest
  if t < old_t
    return find_nearest(rest, ray, [t, obj])
  end
  return find_nearest(rest, ray, nearest)
end

def find_nearest(objects, ray)
  return find_nearest(objects, ray, $miss)
end

def trace(objects, ray, nearest)
  return trace(objects, ray, nearest, 15, true)
end

def trace(objects, ray, _, 0, _)
  return [0,0,0]
end

def trace(objects, ray, nearest, bounce, first)
  if nearest == $unkown
    nearest = find_nearest(objects, ray)
    if nearest == $miss
      return [0, 0, 0]
    end
  end
  [t, obj] = nearest
  [_type, _meh, mat] = obj
  [color, reflexivity, emittance] = mat
  emitted_color = vec3:mul(color, emittance)

  [origin, direction] = ray
  point = vec3:add(origin, vec3:mul(direction, t))

  -- palla tänka på inte sfär
  normal = get_normal(obj, point)
  new_ray = random_reflection(normal)
  -- io:debug_raw(new_ray)


  incoming = trace(objects, [point , new_ray], $unkown, bounce - 1, false)

  thing = vec3:dot(new_ray, normal) * reflexivity

  match incoming
    [0,0,0] -> reflected_color = [0,0,0] end
    _ -> reflected_color = vec3:mul(vec3:proj(color, incoming), thing) end
  end

  return vec3:add(emitted_color, reflected_color)
end

-- ============ RENDERING =================

def plot_pixel(x, y, color)
  f = def (c)
    return min(core:floor(c*255), 255)
  end
  [r, g, b] = color
  io:print_string([
    <<core:ansi_cursor_to(x, y)>>,
    <<core:ansi_color(@f(r), @f(g), @f(b))>>,
    <<'█'>>,
    <<core:ansi_color_reset()>>]
    )
end

def render_line(y, width, height, objects)
  render_pixel = def (x)
    if x == 0
      return $ok
    end
    pixel_ray = get_pixel_ray(x, y, width, height)
    ray = [[0,0,-1], pixel_ray]
    match find_nearest(objects, ray)
      $miss -> color = [0, 0, 0] end
      nearest ->
        color = adaptive_trace(objects, ray, 30 , 500, .05, nearest)
      end
    end
    plot_pixel(x,y,color)
    return @render_pixel(x - 1)
  end
  @render_pixel(width)
  return $ok
end

def render(width, height)
  plain_wall = [[1,1,1],1, 1]
  objects = [
      [-- Backwall 1
        $triangle,
        [
          [-2, 2, 5],
          [-2, -2, 5],
          [2, -2, 5],
        ],
        [[1, 1, 1], 1, 0]
      ],
      [-- Backwall 2
        $triangle,
        [
          [-2, 2, 5],
          [2, 2, 5],
          [2, -2, 5],
        ],
        [[1, 1, 1], 1, 0]
      ],
      [-- Left wall 1
        $triangle,
        [
          [-2, 2, 5],
          [-2, -2, 5],
          [-2, -2, 2],
        ],
        [[.1, .9, .1], 1, 0]
      ],
      [-- Left wall 2
        $triangle,
        [
          [-2, 2, 5],
          [-2, 2, 2],
          [-2, -2, 2],
        ],
        [[.1, .9, .1], 1, 0]
      ],
      [-- right wall 1
        $triangle,
        [
          [2, 2, 5],
          [2, -2, 5],
          [2, -2, 2],
        ],
        [[.9, .1, .1], 1, 0]
      ],
      [-- right wall 2
        $triangle,
        [
          [2, 2, 5],
          [2, 2, 2],
          [2, -2, 2],
        ],
        [[.9, .1, .1], 1, 0]
      ],
      [-- bottom wall 1
        $triangle,
        [
          [2, 2, 5],
          [-2, 2, 5],
          [-2, 2, 2],
        ],
        [[1, 1, 1], 1, 0]
      ],
      [-- bottom wall 2
        $triangle,
        [
          [2, 2, 5],
          [2, 2, 2],
          [-2, 2, 2],
        ],
        [[1, 1, 1], 1, 0]
      ],
      [-- top wall 1
        $triangle,
        [
          [2, -2, 5],
          [-2, -2, 5],
          [-2, -2, 2],
        ],
        [[1, 1, 1], 1, 0]
      ],
      [-- top wall 2
        $triangle,
        [
          [2, -2, 5],
          [2, -2, 2],
          [-2, -2, 2],
        ],
        [[1, 1, 1], 1, 0]
      ],
      [-- Lamp 1
        $triangle,
        [
          [1, -1.9, 4],
          [-1, -1.9, 4],
          [-1, -1.9, 3],
        ],
        [[1, 1, 1], 0, 1]
      ],
      [-- Lamp 2
        $triangle,
        [
          [1, -1.9, 4],
          [1, -1.9, 3],
          [-1, -1.9, 3],
        ],
        [[1, 1, 1], 0, 1]
      ],
      [$sphere, [[-.5,.75,3],.3], [[0.9,0.9,0.9], 0, 1]],
  ]
  -- objects = [
  --   [$sphere, [[0,1.5,2],.7], [[1, 1, 1], 1, .0]],
  --   [$sphere, [[1,1,3],.3], [[0.2,0.8,0.5], .5, .5]],
  --   [$sphere, [[0,0,3],1], [[1,1,1], 1, 0]],
  --   [$triangle, [
  --     [-1, -1, 2],
  --     [0, 1, 3],
  --     [1, -1, 4]
  --   ], [[0,0,1], 1.5, 0]],
  --   [$triangle, [
  --     [0,-2, 4],
  --     [-10, -2, 0],
  --     [10, -2, 0]
  --   ], [[1,1,1], 0, 1]]
  -- ]

  worker = def (y)
    return render_line(y, width, height, objects)
  end

  return list:pmap(list:range(height), worker)

end

def average_trace(objects, ray, samples)
  return average_trace(objects, ray, samples, samples, [0,0,0])
end

def average_trace(objects, ray, 0, samples, col)
  return col
end

def average_trace(objects, ray, n, s, [_r, _g, _b])
  match trace(objects, ray)
    $miss -> return [0,0,0] end
    [r,g,b] -> return average_trace(objects, ray, n - 1, s, [_r + r/s, _g + g/s, _b + b/s]) end
  end
end

def adaptive_trace(objects, ray, set_size, max, threshold, nearest)
  initial_set = trace_set(objects, ray, set_size, nearest)
  return adaptive_trace(objects, ray, set_size, max, threshold, initial_set, nearest)
end

def adaptive_trace(objects, ray, set_size, max, threshold, old_set, nearest)
  set = trace_set(objects, ray, set_size, nearest)
  color = vec3:mul(vec3:add(set, old_set), 1/2)
  diff = vec3:mag(vec3:sub(set, old_set))
  if diff < threshold
    return color
  end
  if set_size * 2 > max
    return color
  end
  return adaptive_trace(objects, ray, set_size*2, max, threshold, color, nearest)
end

def trace_set(objects, ray, s, nearest)
  return trace_set(objects, ray, s, s, [0,0,0], nearest)
end

def trace_set(objects, ray, s, 0, acc, nearest)
  return acc
end

def trace_set(objects, ray, s, n, [_r, _g, _b], nearest)
  match trace(objects, ray, nearest)
    $miss -> return [0,0,0] end
    [r,g,b] -> return trace_set(objects, ray, s, n - 1, [_r + r/s, _g + g/s, _b + b/s], nearest) end
  end
  return 1
end



def _entry([])
  if _test() == false
    return $ok
  end
  io:print_string(core:ansi_cursor_to(0,0))
  io:print_string(core:ansi_clear_screen())
  utils:load_module('colors')
  [width, height] = core:request(core:io_pid(), $get_console_size)
  render(height*2,height)
  return $ok
end

def _test()
  utils:load_module('testing')
  utils:load_module('vec3')
  suite = [
    ['sphere_intersect_test hit',
      def (superv)
        sphere = [[5,0,0],1]
        ray = [[0,0,0], [1,0,0]]
        intersect = sphere_intersect_test(ray, sphere)
        testing:assert(superv, 'does not miss', intersect != $miss)
        testing:assert(superv, 'Hits at [4 0 0]', [4, 0, 0], vec3:mul([1,0,0], intersect))
      end
    ],
    ['sphere_intersect_test miss',
      def (superv)
        sphere = [[0,5,0],1]
        ray = [[0,0,0], [1,0,0]]
        intersect = sphere_intersect_test(ray, sphere)
        testing:assert(superv, 'does not miss', intersect == $miss)
      end
    ],
    ['random_ref',
      def (superv)
        norm = [core:rand_range(-1,1), core:rand_range(-1,1) , core:rand_range(-1,1)]
        testing:assert(superv, 'n·random(n) > 0', vec3:dot(random_reflection(norm),norm) > 0)
      end
    ],
    ['triangle intersection test',
      def (superv)
        triangle = [
          [-1, -1, 0],
          [0, 1, 0],
          [1, -1, 0]
        ]
        ray = [[0,0,-1], [0,0,1]]
        testing:assert(superv, 'hits at 1', triangle_intersect_test(ray, triangle), 1)
        ray = [[0,0,-1], [0,0,-1]]
        testing:assert(superv, 'reversed misses', triangle_intersect_test(ray, triangle), $miss)
      end
    ],
  ]
  return testing:run_suite('Trace', suite)
end
